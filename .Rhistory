version <- 'study-01' #pilot-data-00 (train and test), pilot-data-01 (learn and train), pilot-data-02 (learn and train, learn phase split into two parts)
exp <- 'exp_lt' #experiment: 'exp_ts' (task-switching) or 'exp_lt' (learning transfer)
sess <- c('ses-learn','ses-train') #session: 'ses-learn','ses-train','ses-test'. can select one (e.g. ses <- c('ses-learn')) or multiple (e.g. ses <- c('ses-train','ses-test'))
#   !you can change the following settings if you want to, but the defaults will usually be fine
mes <- 'clicks' #measure: 'clicks' or 'hovers'. usually want 'clicks'.
if(mes=='clicks'){idx <- 1}else{idx <- 2}
apply_threshold <- FALSE #only retain events that lasted more than a given duration?
min_dur <- 0.1 #minimum duration
###
# paths
#   !if you open the project thru doors.Rproj, your working directory will automatically be the project path
project_path <- getwd()
if(!dir.exists(file.path(project_path,'res'))){ # check that the results directory exists. if it doesn't, create it.
dir.create(file.path(project_path,'res'))
}
#   !you will need to change the data path to match the location of OneDrive on your personal computer
data_path <- file.path('/Users/lydiabarnes/OneDrive - UNSW/task switch and transfer/data-sandpit',version)
if (!dir.exists(data_path)){
stop(paste0(data_path,' does not exist'))
}
###
# load an up-to-date list of participants
subs <- get_subs(exp,version)
###
# extract events from the raw data
#   make an empty data frame with all the variables (columns) that we will want
grp_data <- data.frame(
sub = integer(), #subject number
ses = integer(), #session (learn, train, or test)
t = integer(), #trial number
context = integer(),
door = integer(), #which door they are clicking or hovering over
door_correct = integer(), #whether the door is the target
on = numeric(), #when they began this click/hover
off = numeric(), #when they released this click/hover (useful if we want to only count hovers that last more than some duration)
door_cc = integer(), #whether the door belongs to the current context
door_oc = integer(), #whether the door belongs to the other context (for calculating setting accuracy)
switch = integer(), #whether the context on this event is different to the previous event's context
train_type = integer() #whether this person's train phase had a high or low switch rate (only relevant for train and test)
)
#   for each subject and session, use the function 'get_data' to load their raw data and attach it to our 'grp_data' data frame with one measurement (row) per event (click or hover)
for(sub in subs){
for(ses in sess){
train_type <- NA
if(ses == 'ses-test'){ #we calculate people's training group from the switch rate in their train phase data. copy that information into the test phase data
train_type <- grp_data %>% filter(sub == sub & ses == 2) %>% select(train_type)
}
data <- get_data(data_path,exp,sub,ses,train_type,apply_threshold,min_dur) #load and format raw data
grp_data <- rbind(grp_data,data[[idx]]) #add to the 'grp_data' data frame so we end up with all subjects and sessions in one spreadsheet
}
}
#   save the formatted data
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'evt',sep='_'),'.csv',sep = ""))
write_csv(grp_data,fnl)
###
# extract accuracy and response time averages from event data
#   by trial
res <- grp_data %>% group_by(sub,ses,t,context,train_type) %>% summarise(
switch = max(switch), #if the context switched for any event on this trial, it's a switch trial
n_clicks = n(),
n_correct = sum(door_correct),
n_cc = sum(door_cc),
n_oc = sum(door_oc),
accuracy = n_correct/n_clicks,
)
rt <- grp_data %>% group_by(sub,ses,t,context,train_type) %>% filter(door_correct==1) %>% summarise(rt = min(off)) #time to first correct click offset
res$rt <- rt$rt
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'trl',sep='_'),'.csv',sep = ""))
write_csv(res,fnl)
#   by subject
res <- res %>% group_by(sub,ses,context,switch,train_type) %>% summarise(
n_clicks = mean(n_clicks),
n_cc = mean(n_cc),
n_oc = mean(n_oc),
rt = mean(rt),
accuracy = mean(accuracy)
)
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'avg',sep='_'),'.csv',sep = ""))
write_csv(res,fnl)
# lydia barnes, march 2024
# this script extracts, formats, and summarises data from the 'doors' project.
# TODO:
# remove redundancy bw door_correct and door_cc
# produce alternate results grouped by door identity instead of nclicks
###
# sources
library(tidyverse)
source(file.path(getwd(),'src','get_data.R'))
source(file.path(getwd(),'src','get_subs.R'))
###
# settings
#   !you will want to update these settings a lot during piloting, when the task code or the way you test changes, or when you test participants on different subsets of the task phases
version <- 'study-01' #pilot-data-00 (train and test), pilot-data-01 (learn and train), pilot-data-02 (learn and train, learn phase split into two parts)
exp <- 'exp_lt' #experiment: 'exp_ts' (task-switching) or 'exp_lt' (learning transfer)
sess <- c('ses-learn','ses-train') #session: 'ses-learn','ses-train','ses-test'. can select one (e.g. ses <- c('ses-learn')) or multiple (e.g. ses <- c('ses-train','ses-test'))
#   !you can change the following settings if you want to, but the defaults will usually be fine
mes <- 'clicks' #measure: 'clicks' or 'hovers'. usually want 'clicks'.
if(mes=='clicks'){idx <- 1}else{idx <- 2}
apply_threshold <- FALSE #only retain events that lasted more than a given duration?
min_dur <- 0.1 #minimum duration
###
# paths
#   !if you open the project thru doors.Rproj, your working directory will automatically be the project path
project_path <- getwd()
if(!dir.exists(file.path(project_path,'res'))){ # check that the results directory exists. if it doesn't, create it.
dir.create(file.path(project_path,'res'))
}
#   !you will need to change the data path to match the location of OneDrive on your personal computer
data_path <- file.path('/Users/lydiabarnes/OneDrive - UNSW/task switch and transfer/data-sandpit',version)
if (!dir.exists(data_path)){
stop(paste0(data_path,' does not exist'))
}
###
# load an up-to-date list of participants
subs <- get_subs(exp,version)
###
# extract events from the raw data
#   make an empty data frame with all the variables (columns) that we will want
grp_data <- data.frame(
sub = integer(), #subject number
ses = integer(), #session (learn, train, or test)
t = integer(), #trial number
context = integer(),
door = integer(), #which door they are clicking or hovering over
door_correct = integer(), #whether the door is the target
on = numeric(), #when they began this click/hover
off = numeric(), #when they released this click/hover (useful if we want to only count hovers that last more than some duration)
door_cc = integer(), #whether the door belongs to the current context
door_oc = integer(), #whether the door belongs to the other context (for calculating setting accuracy)
switch = integer(), #whether the context on this event is different to the previous event's context
train_type = integer() #whether this person's train phase had a high or low switch rate (only relevant for train and test)
)
#   for each subject and session, use the function 'get_data' to load their raw data and attach it to our 'grp_data' data frame with one measurement (row) per event (click or hover)
for(sub in subs){
for(ses in sess){
train_type <- NA
if(ses == 'ses-test'){ #we calculate people's training group from the switch rate in their train phase data. copy that information into the test phase data
train_type <- grp_data %>% filter(sub == sub & ses == 2) %>% select(train_type)
}
data <- get_data(data_path,exp,sub,ses,train_type,apply_threshold,min_dur) #load and format raw data
grp_data <- rbind(grp_data,data[[idx]]) #add to the 'grp_data' data frame so we end up with all subjects and sessions in one spreadsheet
}
}
#   save the formatted data
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'evt',sep='_'),'.csv',sep = ""))
write_csv(grp_data,fnl)
###
# extract accuracy and response time averages from event data
#   by trial
res <- grp_data %>% group_by(sub,ses,t,context,train_type) %>% summarise(
switch = max(switch), #if the context switched for any event on this trial, it's a switch trial
n_clicks = n(),
n_correct = sum(door_correct),
n_cc = sum(door_cc),
n_oc = sum(door_oc),
accuracy = n_correct/n_clicks,
)
rt <- grp_data %>% group_by(sub,ses,t,context,train_type) %>% filter(door_correct==1) %>% summarise(rt = min(off)) #time to first correct click offset
res$rt <- rt$rt
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'trl',sep='_'),'.csv',sep = ""))
write_csv(res,fnl)
#   by subject
res <- res %>% group_by(sub,ses,context,switch,train_type) %>% summarise(
n_clicks = mean(n_clicks),
n_cc = mean(n_cc),
n_oc = mean(n_oc),
rt = mean(rt),
accuracy = mean(accuracy)
)
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'avg',sep='_'),'.csv',sep = ""))
write_csv(res,fnl)
View(grp_data)
# lydia barnes, march 2024
# this script extracts, formats, and summarises data from the 'doors' project.
# TODO:
# remove redundancy bw door_correct and door_cc
# produce alternate results grouped by door identity instead of nclicks
###
# sources
library(tidyverse)
source(file.path(getwd(),'src','get_data.R'))
source(file.path(getwd(),'src','get_subs.R'))
###
# settings
#   !you will want to update these settings a lot during piloting, when the task code or the way you test changes, or when you test participants on different subsets of the task phases
version <- 'study-01' #pilot-data-00 (train and test), pilot-data-01 (learn and train), pilot-data-02 (learn and train, learn phase split into two parts)
exp <- 'exp_lt' #experiment: 'exp_ts' (task-switching) or 'exp_lt' (learning transfer)
sess <- c('ses-learn','ses-train','ses-test') #session: 'ses-learn','ses-train','ses-test'. can select one (e.g. ses <- c('ses-learn')) or multiple (e.g. ses <- c('ses-train','ses-test'))
#   !you can change the following settings if you want to, but the defaults will usually be fine
mes <- 'clicks' #measure: 'clicks' or 'hovers'. usually want 'clicks'.
if(mes=='clicks'){idx <- 1}else{idx <- 2}
apply_threshold <- FALSE #only retain events that lasted more than a given duration?
min_dur <- 0.1 #minimum duration
###
# paths
#   !if you open the project thru doors.Rproj, your working directory will automatically be the project path
project_path <- getwd()
if(!dir.exists(file.path(project_path,'res'))){ # check that the results directory exists. if it doesn't, create it.
dir.create(file.path(project_path,'res'))
}
#   !you will need to change the data path to match the location of OneDrive on your personal computer
data_path <- file.path('/Users/lydiabarnes/OneDrive - UNSW/task switch and transfer/data-sandpit',version)
if (!dir.exists(data_path)){
stop(paste0(data_path,' does not exist'))
}
###
# load an up-to-date list of participants
subs <- get_subs(exp,version)
###
# extract events from the raw data
#   make an empty data frame with all the variables (columns) that we will want
grp_data <- data.frame(
sub = integer(), #subject number
ses = integer(), #session (learn, train, or test)
t = integer(), #trial number
context = integer(),
door = integer(), #which door they are clicking or hovering over
door_correct = integer(), #whether the door is the target
on = numeric(), #when they began this click/hover
off = numeric(), #when they released this click/hover (useful if we want to only count hovers that last more than some duration)
door_cc = integer(), #whether the door belongs to the current context
door_oc = integer(), #whether the door belongs to the other context (for calculating setting accuracy)
switch = integer(), #whether the context on this event is different to the previous event's context
train_type = integer() #whether this person's train phase had a high or low switch rate (only relevant for train and test)
)
#   for each subject and session, use the function 'get_data' to load their raw data and attach it to our 'grp_data' data frame with one measurement (row) per event (click or hover)
for(sub in subs){
for(ses in sess){
train_type <- NA
if(ses == 'ses-test'){ #we calculate people's training group from the switch rate in their train phase data. copy that information into the test phase data
train_type <- grp_data %>% filter(sub == sub & ses == 2) %>% select(train_type)
}
data <- get_data(data_path,exp,sub,ses,train_type,apply_threshold,min_dur) #load and format raw data
grp_data <- rbind(grp_data,data[[idx]]) #add to the 'grp_data' data frame so we end up with all subjects and sessions in one spreadsheet
}
}
#   save the formatted data
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'evt',sep='_'),'.csv',sep = ""))
write_csv(grp_data,fnl)
###
# extract accuracy and response time averages from event data
#   by trial
res <- grp_data %>% group_by(sub,ses,t,context,train_type) %>% summarise(
switch = max(switch), #if the context switched for any event on this trial, it's a switch trial
n_clicks = n(),
n_correct = sum(door_correct),
n_cc = sum(door_cc),
n_oc = sum(door_oc),
accuracy = n_correct/n_clicks,
)
rt <- grp_data %>% group_by(sub,ses,t,context,train_type) %>% filter(door_correct==1) %>% summarise(rt = min(off)) #time to first correct click offset
res$rt <- rt$rt
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'trl',sep='_'),'.csv',sep = ""))
write_csv(res,fnl)
#   by subject
res <- res %>% group_by(sub,ses,context,switch,train_type) %>% summarise(
n_clicks = mean(n_clicks),
n_cc = mean(n_cc),
n_oc = mean(n_oc),
rt = mean(rt),
accuracy = mean(accuracy)
)
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'avg',sep='_'),'.csv',sep = ""))
write_csv(res,fnl)
View(res)
# lydia barnes, april 2024
# this script plots optimal and observed search path data for the doors project
# NB:
#   at 2024.04.30, i've calculated optimal paths for the contexts used in the learn and train phases.
#   for exp_ts, those same contexts appear in the test phase, too. i haven't calculated optimal paths
#   for the new contexts introduced during exp_lt's test phase. we plan to use people's path adherence
#   during the train phase to predict performance gains during training and test, so at the moment,
#   test phase optimal paths aren't relevant. if they become important, extend the context indices in
#   format_paths.R and in get_shortest_path.py.
# TODO:
#
###
# sources
library(tidyverse)
library(tidyjson)
###
# settings
#   which dataset?
version <- 'study-01' #pilot-data-00 (train and test), pilot-data-01 (learn and train), pilot-data-02 (learn and train, learn phase split into two parts)
exp <- 'exp_lt' #experiment: 'exp_ts' (task-switching) or 'exp_lt' (learning transfer)
mes <- 'clicks' #measure: 'clicks' or 'hovers'. usually want 'clicks'.
#   which subject, algorithm, context, session, and trials would you like to view?
subject <- 1 #subject id, as integer
alg <- 'hc' #shortest path algorithm: 'hc' (hamiltonian cycle) or 'tsp' (travelling salesperson)
ctx <- 2 #context: 1 or 2
session <- 2 #session (i.e. learn or train): 1 = learn, 2 = train
idx <- c(1,40,80,120,160) #which trials you'd like to view within this context and session
#   how would you like the figure to look?
title_sz <- 30
label_sz <- 30
###
# read the optimal path data
#   get the working directory
project_path <- getwd()
#   read the data
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'opt-path',sep='_'),'.csv',sep=''))
optimal <- read_csv(fnl,show_col_types = FALSE)
# lydia barnes, april 2024
# this script formats optimal search path data for the doors project
###
# sources
library(tidyverse)
library(tidyjson)
source(file.path(getwd(),'src','get_subs.R'))
# settings
version <- 'study-01' #pilot-data-00 (train and test), pilot-data-01 (learn and train), pilot-data-02 (learn and train, learn phase split into two parts)
exp <- 'exp_lt' #experiment: 'exp_ts' (task-switching) or 'exp_lt' (learning transfer)
mes <- 'clicks' #measure: 'clicks' or 'hovers'. usually want 'clicks'.
# paths
project_path <- getwd()
###
# format the optimal path data
#   make an empty data frame
optimal <- data.frame(
sub = integer(),
algorithm = character(),
solution = integer(),
context = integer(),
door = integer(),
x = integer(),
y = integer()
)
#   map door IDs to x and y positions
xloc = c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4)
yloc = c(4,3,2,1,4,3,2,1,4,3,2,1,4,3,2,1)
#   extract optimal paths for each algorithm, subject, and context
algs <- c('hc','tsp') #shortest path method: 'hc' (hamiltonian cycle) and 'tsp' (travelling salesperson)
contexts <- c(1,2) #context: 1 or 2
for(alg in algs){
# read the optimal path data
fnl <- file.path(project_path,'src-paths',paste(paste(alg,'solutions',sep='_'),'.json',sep=''))
tmp <- read_json(fnl)
tmp <- tmp$..JSON
tmp <- tmp[[1]]
for(subject in 1:length(tmp)){
for(ctx in contexts){
#   find the relevant optimal paths
opt <- tmp[[subject]][[ctx]]
for(i in 1:length(opt)){
door <- unlist(opt[[i]])
sub <- rep(subject,length(door))
algorithm <- rep(alg,length(door))
solution <- rep(i,length(door))
context <- rep(ctx,length(door))
x <- xloc[door]
y <- yloc[door]
optimal <- rbind(optimal,data.frame(sub,algorithm,solution,context,door,x,y))
}
}
}
}
###
# save the formatted path data
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'opt-path',sep='_'),'.csv',sep=''))
write_csv(optimal,fnl)
# lydia barnes, april 2024
# this script plots optimal and observed search path data for the doors project
# NB:
#   at 2024.04.30, i've calculated optimal paths for the contexts used in the learn and train phases.
#   for exp_ts, those same contexts appear in the test phase, too. i haven't calculated optimal paths
#   for the new contexts introduced during exp_lt's test phase. we plan to use people's path adherence
#   during the train phase to predict performance gains during training and test, so at the moment,
#   test phase optimal paths aren't relevant. if they become important, extend the context indices in
#   format_paths.R and in get_shortest_path.py.
# TODO:
#
###
# sources
library(tidyverse)
library(tidyjson)
###
# settings
#   which dataset?
version <- 'study-01' #pilot-data-00 (train and test), pilot-data-01 (learn and train), pilot-data-02 (learn and train, learn phase split into two parts)
exp <- 'exp_lt' #experiment: 'exp_ts' (task-switching) or 'exp_lt' (learning transfer)
mes <- 'clicks' #measure: 'clicks' or 'hovers'. usually want 'clicks'.
#   which subject, algorithm, context, session, and trials would you like to view?
subject <- 1 #subject id, as integer
alg <- 'hc' #shortest path algorithm: 'hc' (hamiltonian cycle) or 'tsp' (travelling salesperson)
ctx <- 2 #context: 1 or 2
session <- 2 #session (i.e. learn or train): 1 = learn, 2 = train
idx <- c(1,40,80,120,160) #which trials you'd like to view within this context and session
#   how would you like the figure to look?
title_sz <- 30
label_sz <- 30
###
# read the optimal path data
#   get the working directory
project_path <- getwd()
#   read the data
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'opt-path',sep='_'),'.csv',sep=''))
optimal <- read_csv(fnl,show_col_types = FALSE)
###
# read the observed path data
#   read the data
fnl <- file.path(project_path,'res',paste(paste(version,exp,mes,'evt',sep='_'),'.csv',sep=''))
observed <- read_csv(fnl,show_col_types = FALSE)
#   re-code door ID as x and y grid positions
xloc <-  c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4)
yloc <-  c(4,3,2,1,4,3,2,1,4,3,2,1,4,3,2,1)
id <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
count <- c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
doors <- data.frame(xloc,yloc,id,count)
observed <- observed %>% mutate(x = xloc[door],y = yloc[door])
###
# plot!
#   filter to just this subject, algorithm, context, and session
opt <- optimal %>% filter(sub == subject,algorithm == alg,context == ctx) %>% mutate(solution_factor = factor(solution))
obs <- observed %>% filter(sub == subject,context == ctx,ses==session)
trials <- unique(obs$t)
length(trials)
obs <- obs %>% filter(t %in% trials[idx]) %>% mutate(t_factor = factor(t))
#   make the figure
ggplot() +
geom_tile(data = doors, aes(x=xloc,y=yloc,fill=id,colour="white"),show.legend=FALSE,width = .9, height = .9, alpha = 1.0) +
geom_text(data = doors, aes(x = xloc, y = yloc, label = id),size = 10) +
geom_path(data = opt, aes(x = x, y = y, group = solution_factor),linewidth = 2,linejoin = "mitre", lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
geom_path(data = obs, aes(x = x, y = y, group = t_factor, colour = t_factor),linewidth = 2,linejoin = "mitre",lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
#geom_point(data = obs, aes(x = x, y = y, colour = t_factor),size = 4,position = position_jitter(width = .1)) +
theme_minimal() +
ylim(0.5,4.5) +
xlim(0.5,4.5) +
scale_fill_gradientn(colours = c("white","white"),guide = "none") +
scale_colour_brewer(palette = "BrBG", labels = c(idx,"")) +
labs(title = "Optimal and Observed Paths During Training",x = "Door Position (x)", y = "Door Position (y)",colour = "Trial") +
theme(plot.title = element_text(size = title_sz),
axis.text.x = element_text(size = label_sz),axis.text.y = element_text(size = label_sz),legend.text = element_text(size=label_sz),
axis.title.x = element_text(size = label_sz), axis.title.y = element_text(size = label_sz),legend.title=element_text(size=label_sz))
#   save it
fnl <- file.path(project_path,'fig',paste(paste(version,exp,session,mes,alg,'opt-path',paste('sub',subject,sep="-"),sep='_'),'.pdf',sep = ""))
ggsave(fnl,plot = last_plot())
#   make the figure
ggplot() +
geom_tile(data = doors, aes(x=xloc,y=yloc,fill=id,colour="white"),show.legend=FALSE,width = .9, height = .9, alpha = 1.0) +
geom_text(data = doors, aes(x = xloc, y = yloc, label = id),size = 10) +
geom_path(data = opt, aes(x = x, y = y, group = solution_factor),linewidth = 2,linejoin = "mitre", lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
geom_path(data = obs, aes(x = x, y = y, group = t_factor, colour = t_factor),linewidth = 2,linejoin = "mitre",lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
#geom_point(data = obs, aes(x = x, y = y, colour = t_factor),size = 4,position = position_jitter(width = .1)) +
theme_minimal() +
ylim(0.5,4.5) +
xlim(0.5,4.5) +
scale_fill_gradientn(colours = c("white","white"),guide = "none") +
scale_colour_brewer(palette = "BrBG", labels = c(idx,"")) +
labs(title = "Optimal and Observed Paths During Training",x = "Door Position (x)", y = "Door Position (y)",colour = "Trial") +
theme(plot.title = element_text(size = title_sz),
axis.text.x = element_text(size = label_sz),axis.text.y = element_text(size = label_sz),legend.text = element_text(size=label_sz),
axis.title.x = element_text(size = label_sz), axis.title.y = element_text(size = label_sz),legend.title=element_text(size=label_sz))
#   save it
fnl <- file.path(project_path,'fig',paste(paste(version,exp,session,mes,alg,'opt-path',paste('sub',subject,sep="-"),sep='_'),'.pdf',sep = ""))
ggsave(fnl,plot = last_plot())
#   make the figure
ggplot() +
geom_tile(data = doors, aes(x=xloc,y=yloc,fill=id,colour="white"),show.legend=FALSE,width = .9, height = .9, alpha = 1.0) +
geom_text(data = doors, aes(x = xloc, y = yloc, label = id),size = 10) +
geom_path(data = opt, aes(x = x, y = y, group = solution_factor),linewidth = 2,linejoin = "mitre", lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
geom_path(data = obs, aes(x = x, y = y, group = t_factor, colour = t_factor),linewidth = 2,linejoin = "mitre",lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
#geom_point(data = obs, aes(x = x, y = y, colour = t_factor),size = 4,position = position_jitter(width = .1)) +
theme_minimal() +
ylim(0.5,4.5) +
xlim(0.5,4.5) +
scale_fill_gradientn(colours = c("white","white"),guide = "none") +
scale_colour_brewer(palette = "BrBG", labels = c(idx,"")) +
labs(title = "Optimal and Observed Paths During Training",x = "Door Position (x)", y = "Door Position (y)",colour = "Trial") +
theme(plot.title = element_text(size = title_sz),
axis.text.x = element_text(size = label_sz),axis.text.y = element_text(size = label_sz),legend.text = element_text(size=label_sz),
axis.title.x = element_text(size = label_sz), axis.title.y = element_text(size = label_sz),legend.title=element_text(size=label_sz))
#   save it
fnl <- file.path(project_path,'fig',paste(paste(version,exp,session,mes,alg,'opt-path',paste('sub',subject,sep="-"),sep='_'),'.pdf',sep = ""))
ggsave(fnl,plot = last_plot())
#   make the figure
ggplot() +
geom_tile(data = doors, aes(x=xloc,y=yloc,fill=id,colour="white"),show.legend=FALSE,width = .9, height = .9, alpha = 1.0) +
geom_text(data = doors, aes(x = xloc, y = yloc, label = id),size = 10) +
geom_path(data = opt, aes(x = x, y = y, group = solution_factor),linewidth = 2,linejoin = "mitre", lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
geom_path(data = obs, aes(x = x, y = y, group = t_factor, colour = t_factor),linewidth = 2,linejoin = "mitre",lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
#geom_point(data = obs, aes(x = x, y = y, colour = t_factor),size = 4,position = position_jitter(width = .1)) +
theme_minimal() +
ylim(0.5,4.5) +
xlim(0.5,4.5) +
scale_fill_gradientn(colours = c("white","white"),guide = "none") +
scale_colour_brewer(palette = "BrBG", labels = c(idx,"")) +
labs(title = "Optimal and Observed Paths During Training",x = "Door Position (x)", y = "Door Position (y)",colour = "Trial") +
theme(plot.title = element_text(size = title_sz),
axis.text.x = element_text(size = label_sz),axis.text.y = element_text(size = label_sz),legend.text = element_text(size=label_sz),
axis.title.x = element_text(size = label_sz), axis.title.y = element_text(size = label_sz),legend.title=element_text(size=label_sz))
#   save it
fnl <- file.path(project_path,'fig',paste(paste(version,exp,session,mes,alg,'opt-path',paste('sub',subject,sep="-"),sep='_'),'.pdf',sep = ""))
ggsave(fnl,plot = last_plot())
#   make the figure
ggplot() +
geom_tile(data = doors, aes(x=xloc,y=yloc,fill=id,colour="white"),show.legend=FALSE,width = .9, height = .9, alpha = 1.0) +
geom_text(data = doors, aes(x = xloc, y = yloc, label = id),size = 10) +
geom_path(data = opt, aes(x = x, y = y, group = solution_factor),linewidth = 2,linejoin = "mitre", lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
geom_path(data = obs, aes(x = x, y = y, group = t_factor, colour = t_factor),linewidth = 2,linejoin = "mitre",lineend = "butt",position = position_jitter(width = .1),alpha = .8,arrow = arrow(angle = 15, type = "closed")) +
#geom_point(data = obs, aes(x = x, y = y, colour = t_factor),size = 4,position = position_jitter(width = .1)) +
theme_minimal() +
ylim(0.5,4.5) +
xlim(0.5,4.5) +
scale_fill_gradientn(colours = c("white","white"),guide = "none") +
scale_colour_brewer(palette = "BrBG", labels = c(idx,"")) +
labs(title = "Optimal and Observed Paths During Training",x = "Door Position (x)", y = "Door Position (y)",colour = "Trial") +
theme(plot.title = element_text(size = title_sz),
axis.text.x = element_text(size = label_sz),axis.text.y = element_text(size = label_sz),legend.text = element_text(size=label_sz),
axis.title.x = element_text(size = label_sz), axis.title.y = element_text(size = label_sz),legend.title=element_text(size=label_sz))
#   save it
fnl <- file.path(project_path,'fig',paste(paste(version,exp,session,mes,alg,'opt-path',paste('sub',subject,sep="-"),sep='_'),'.pdf',sep = ""))
ggsave(fnl,plot = last_plot())
